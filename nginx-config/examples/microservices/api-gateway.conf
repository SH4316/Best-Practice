# 마이크로서비스 및 API 게이트웨이 설정 예제

# 1. 기본 API 게이트웨이 설정
http {
    # 마이크로서비스 업스트림 정의
    upstream user_service {
        least_conn;
        server 192.168.1.101:8001;
        server 192.168.1.102:8001;
    }
    
    upstream product_service {
        least_conn;
        server 192.168.1.201:8002;
        server 192.168.1.202:8002;
    }
    
    upstream order_service {
        least_conn;
        server 192.168.1.301:8003;
        server 192.168.1.302:8003;
    }
    
    server {
        listen 80;
        server_name api.example.com;
        
        # 사용자 서비스
        location /api/users/ {
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS 헤더
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Content-Type, Authorization";
        }
        
        # 제품 서비스
        location /api/products/ {
            proxy_pass http://product_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS 헤더
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Content-Type, Authorization";
        }
        
        # 주문 서비스
        location /api/orders/ {
            proxy_pass http://order_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS 헤더
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Content-Type, Authorization";
        }
    }
}

# 2. DNS 기반 서비스 디스커버리
http {
    # DNS 리졸버 설정
    resolver 127.0.0.1 valid=30s;
    
    server {
        listen 80;
        server_name discovery.example.com;
        
        # 동적 서비스 디스커버리
        location /api/users/ {
            set $user_service "user-service.default.svc.cluster.local";
            proxy_pass http://$user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        location /api/products/ {
            set $product_service "product-service.default.svc.cluster.local";
            proxy_pass http://$product_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        location /api/orders/ {
            set $order_service "order-service.default.svc.cluster.local";
            proxy_pass http://$order_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}

# 3. API 버전 관리
http {
    # v1 서비스
    upstream user_service_v1 {
        server 192.168.1.101:8001;
        server 192.168.1.102:8001;
    }
    
    upstream product_service_v1 {
        server 192.168.1.201:8002;
        server 192.168.1.202:8002;
    }
    
    # v2 서비스
    upstream user_service_v2 {
        server 192.168.1.111:8011;
        server 192.168.1.112:8011;
    }
    
    upstream product_service_v2 {
        server 192.168.1.211:8012;
        server 192.168.1.212:8012;
    }
    
    server {
        listen 80;
        server_name versioned.example.com;
        
        # v1 API
        location /api/v1/users/ {
            proxy_pass http://user_service_v1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-API-Version "v1";
        }
        
        location /api/v1/products/ {
            proxy_pass http://product_service_v1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-API-Version "v1";
        }
        
        # v2 API
        location /api/v2/users/ {
            proxy_pass http://user_service_v2;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-API-Version "v2";
        }
        
        location /api/v2/products/ {
            proxy_pass http://product_service_v2;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-API-Version "v2";
        }
        
        # 기본 버전 (v2)
        location /api/users/ {
            return 302 /api/v2$request_uri;
        }
        
        location /api/products/ {
            return 302 /api/v2$request_uri;
        }
    }
}

# 4. 속도 제한 및 할당량
http {
    # 속도 제한 영역 정의
    limit_req_zone $binary_remote_addr zone=global:10m rate=100r/m;
    limit_req_zone $http_x_user_id zone=user:10m rate=1000r/h;
    limit_req_zone $http_x_api_key zone=api_key:10m rate=10000r/h;
    
    # API 키 할당량 맵
    geo $api_key_quota {
        default 100;
        1234567890abcdef 1000;  # 프리미엄 고객
        fedcba0987654321 500;    # 일반 고객
    }
    
    server {
        listen 80;
        server_name rate-limited.example.com;
        
        # 전역 속도 제한
        limit_req zone=global burst=20 nodelay;
        
        # API 키 기반 속도 제한
        location /api/ {
            # API 키 확인
            if ($http_x_api_key = "") {
                return 401;
            }
            
            # 동적 속도 제한
            limit_req zone=api_key burst=$api_key_quota nodelay;
            
            # 사용자 ID 기반 속도 제한
            limit_req zone=user burst=100 nodelay;
            
            # 사용자 서비스
            location /api/users/ {
                proxy_pass http://user_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header X-API-Key $http_x_api_key;
            }
            
            # 제품 서비스
            location /api/products/ {
                proxy_pass http://product_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header X-API-Key $http_x_api_key;
            }
        }
    }
}

# 5. JWT 기반 인증 (Lua 모듈 필요)
http {
    # 인증 서비스
    upstream auth_service {
        server 192.168.1.50:9000;
    }
    
    server {
        listen 80;
        server_name auth.example.com;
        
        # 로그인 엔드포인트 (인증 필요 없음)
        location /api/auth/login {
            proxy_pass http://auth_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # 토큰 갱신 엔드포인트
        location /api/auth/refresh {
            proxy_pass http://auth_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # 인증이 필요한 API
        location /api/ {
            # JWT 검증 (Lua 스크립트 필요)
            access_by_lua_block {
                local jwt = require "resty.jwt"
                local jwt_secret = "your-secret-key"
                
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say("Missing authorization header")
                    ngx.exit(401)
                end
                
                local _, _, token = string.find(auth_header, "Bearer%s+(.+)")
                if not token then
                    ngx.status = 401
                    ngx.say("Invalid authorization header")
                    ngx.exit(401)
                end
                
                local jwt_obj = jwt:verify_jwt(jwt_secret, token)
                if not jwt_obj.valid then
                    ngx.status = 401
                    ngx.say("Invalid token: " .. jwt_obj.reason)
                    ngx.exit(401)
                end
                
                -- 사용자 정보를 헤더에 추가
                ngx.req.set_header("X-User-ID", jwt_obj.payload.sub)
                ngx.req.set_header("X-User-Role", jwt_obj.payload.role)
            }
            
            # 사용자 서비스
            location /api/users/ {
                proxy_pass http://user_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            
            # 관리자 전용 API
            location /api/admin/ {
                access_by_lua_block {
                    local user_role = ngx.req.get_headers()["X-User-Role"]
                    if user_role ~= "admin" then
                        ngx.status = 403
                        ngx.say("Access denied")
                        ngx.exit(403)
                    end
                }
                
                proxy_pass http://admin_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
    }
}

# 6. 요청/응답 변환 (Lua 모듈 필요)
http {
    # 사용자 서비스
    upstream user_service {
        server 192.168.1.101:8001;
    }
    
    server {
        listen 80;
        server_name transform.example.com;
        
        # 레거시 형식을 새 형식으로 변환
        location /api/legacy/users/ {
            # 요청 본문 변환
            rewrite ^/api/legacy/(.*)$ /api/$1 break;
            
            # 레거시 응답 형식으로 변환
            body_filter_by_lua_block {
                local cjson = require "cjson"
                local data = cjson.decode(ngx.arg[1])
                
                -- 새 형식을 레거시 형식으로 변환
                local legacy_data = {
                    status = "success",
                    result = {
                        userId = data.id,
                        userName = data.name,
                        userEmail = data.email
                    }
                }
                
                ngx.arg[1] = cjson.encode(legacy_data)
            }
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # 새 형식의 API
        location /api/users/ {
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}

# 7. 모니터링 및 로깅
http {
    # 분산 추적을 위한 헤더
    map $http_x_request_id $request_id {
        default $http_x_request_id;
        "" $request_id;
    }
    
    # 로그 형식 정의
    log_format microservices '$remote_addr - $remote_user [$time_local] "$request" '
                            '$status $body_bytes_sent "$http_referer" '
                            '"$http_user_agent" "$http_x_forwarded_for" '
                            'rt=$request_time uct="$upstream_connect_time" '
                            'uht="$upstream_header_time" urt="$upstream_response_time" '
                            'req_id=$request_id service=$service_name';
    
    server {
        listen 80;
        server_name monitoring.example.com;
        
        # 요청 ID 생성
        set $request_id $request_id;
        if ($request_id = "") {
            set $request_id $request_id;
        }
        
        # 요청 ID 헤더 추가
        add_header X-Request-ID $request_id;
        
        # 사용자 서비스
        location /api/users/ {
            set $service_name "user_service";
            access_log /var/log/nginx/user_service.log microservices;
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Request-ID $request_id;
            
            # 응답 시간 헤더
            add_header X-Response-Time $upstream_response_time;
        }
        
        # 제품 서비스
        location /api/products/ {
            set $service_name "product_service";
            access_log /var/log/nginx/product_service.log microservices;
            
            proxy_pass http://product_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Request-ID $request_id;
            
            # 응답 시간 헤더
            add_header X-Response-Time $upstream_response_time;
        }
        
        # API 상태 엔드포인트
        location /api/status {
            default_type application/json;
            return 200 '{"status": "healthy", "timestamp": "$time_iso8601", "request_id": "$request_id"}';
        }
    }
}

# 8. 회로 차단기 패턴 (Lua 모듈 필요)
http {
    # 회로 차단기 상태 저장소
    lua_shared_dict circuit_breaker 10m;
    
    server {
        listen 80;
        server_name circuit-breaker.example.com;
        
        location /api/users/ {
            # 회로 차단기 로직
            access_by_lua_block {
                local cb = ngx.shared.circuit_breaker
                local key = "user_service"
                local state = cb:get(key) or "closed"
                local failures = tonumber(cb:get(key .. ":failures") or 0)
                local last_failure = tonumber(cb:get(key .. ":last_failure") or 0)
                local now = ngx.time()
                
                -- 반开放的冷却时间检查
                if state == "half-open" and (now - last_failure) > 30 then
                    state = "closed"
                    failures = 0
                    cb:set(key, state)
                    cb:set(key .. ":failures", failures)
                end
                
                -- 开路状态检查
                if state == "open" and (now - last_failure) > 60 then
                    state = "half-open"
                    cb:set(key, state)
                end
                
                -- 开路状态直接返回错误
                if state == "open" then
                    ngx.status = 503
                    ngx.say("Service temporarily unavailable")
                    ngx.exit(503)
                end
            }
            
            # 响应后处理
            body_filter_by_lua_block {
                local cb = ngx.shared.circuit_breaker
                local key = "user_service"
                local status = ngx.status
                
                if status >= 500 then
                    local failures = tonumber(cb:get(key .. ":failures") or 0) + 1
                    cb:set(key .. ":failures", failures)
                    cb:set(key .. ":last_failure", ngx.time())
                    
                    -- 达到失败阈值时打开电路
                    if failures >= 5 then
                        cb:set(key, "open")
                    end
                elseif state == "half-open" and status < 500 then
                    -- 半开放状态下成功则关闭电路
                    cb:set(key, "closed")
                    cb:set(key .. ":failures", 0)
                end
            }
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}